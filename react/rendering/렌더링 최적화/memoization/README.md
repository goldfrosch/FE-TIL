# React.memo()

- 리액트에서 기본적으로 제공되는 고차 컴포넌트.
- ### 고차 컴포넌트?

  - 컴포넌트 작성 중에 반복적으로 로직을 작성 해야하는 경우가 존재한다. 고차 컴포넌트는 컴포넌트를 입력받아 어떠한 기능을 수행한 후 컴포넌트를 반환(return)한다. 반복적인 로직들을 고차 컴포넌트를 이용해 추상화 할 경우 공통적인 기능을 분리할 수 있다.
  - 우선 고차함수에 대해 알 필요가 있다.

  ```
    const test = () => {
      console.log("이건 테스트야");
    }
    const highFunc = (test) => {
        console.log('곶차함수')
        return inputFunc
    }
    const higherOrder = higherFunc(test)
    higherOrder()
  ```

  result

  ```
    곶차함수
    이건 테스트야
  ```

  함수를 함수로 감싸 특정 로직을 먼저 실행한 후 그 안의 함수를 실행시키는 방식이 고차함수다.

  즉 고차 컴포넌트는 컴포넌트를 컴포넌트로 감싸 우선적으로 수행해야할 내용을 수행한 후 return해주는 기능이라고 할 수 있다.

- React.memo는 고차 컴포넌트로 props의 변화가 있는지를 탐색해 없을 경우 리렌더링을 방지해주는 기능을 가지고 있다.

- 이러한 탐색들은 shallow equality (얕은 탐색)을 통해서 확인이 가능하다. 얕은 탐색이란 서로 다른 두 객체의 모든 개별 필드를 확인하고 서로 다른 값이 있는지 확인한다.

- 별로 알려진 기능들은 아니지만 (이라고 문서에는 있는데 내보기엔 다 알려진...) 리액트의 컴포넌트가 마지막으로 렌더링 출력에서 정확하게 동일한 컴포넌트를 반환하는 경우 React는 특정한 하위 컴포넌트들을 다시 렌더링 하지 않는다.

  - props에 들어가있는 children은 리렌더링의 요소에 들어가지 않는다. (children을 자주 써서 알아서 리렌더링 안하게 하는것도 참 좋아보인다!)
  - useMemo로 메모지네이션을 한 요소들도 리렌더링의 요소에 들어가지 않는다.

- React.memo와의 차이점은 react.memo는 자식 컴포넌트에 의해 제어된다면 위의 두개는 부모 컴포넌트에 의해 제어된다는 차이다.

- 이렇듯 모든 방식에서 컴포넌트 렌더링을 건너 뛴다라는 것은 해당 하위 트리의 렌더링도 전부 건너뛰는 의미기 때문에 성능에 효과가 있을 수 있다.
