# 렌더링 최적화

## 렌더링의 성능 개선

렌더링은 리액트에서 state나 props가 변경될 경우에 자연스럽게 일어나는 현상이지만, 이 작업이 때때로는 낭비가 되는 경우가 존재한다.
구성요소가 변경되지 않고 DOM의 해당 부분을 업데이트 할 필요가 없는데도 렌더링을 계산하는 행위는 매우 낭비다.

특정 컴포넌트에 대해 state나 props가 변해 다시 그리지 않는 이상은 렌더링 작업을 건너뛰어도 된다고 미리 알고 있으면 조금 더 성능이 향상될 수 있지 않을까...

일반적으로 소프트웨어의 성능을 향상시킨다면 기본적으로 2가지 접근법이 존재한다.

1. 동일한 작업을 더 빠르게 수행
2. 불필요한 작업을 수행하지 않음

## 불필요한 렌더링 방지법

크게 3가지 요소가 존재한다.

- React.memo()

  - 리액트에서 기본적으로 제공되는 고차 컴포넌트.
  - ### 고차 컴포넌트?

    - 컴포넌트 작성 중에 반복적으로 로직을 작성 해야하는 경우가 존재한다. 고차 컴포넌트는 컴포넌트를 입력받아 어떠한 기능을 수행한 후 컴포넌트를 반환(return)한다. 반복적인 로직들을 고차 컴포넌트를 이용해 추상화 할 경우 공통적인 기능을 분리할 수 있다.
    - 우선 고차함수에 대해 알 필요가 있다.

    ```
      const test = () => {
        console.log("이건 테스트야");
      }
      const highFunc = (test) => {
          console.log('곶차함수')
          return inputFunc
      }
      const higherOrder = higherFunc(test)
      higherOrder()
    ```

    result

    ```
      곶차함수
      이건 테스트야
    ```

    함수를 함수로 감싸 특정 로직을 먼저 실행한 후 그 안의 함수를 실행시키는 방식이 고차함수다.

    즉 고차 컴포넌트는 컴포넌트를 컴포넌트로 감싸 우선적으로 수행해야할 내용을 수행한 후 return해주는 기능이라고 할 수 있다.

  - React.memo는 고차 컴포넌트로 props의 변화가 있는지를 탐색해 없을 경우 리렌더링을 방지해주는 기능을 가지고 있다.

  - 이러한 탐색들은 shallow equality (얕은 탐색)을 통해서 확인이 가능하다. 얕은 탐색이란 서로 다른 두 객체의 모든 개별 필드를 확인하고 서로 다른 값이 있는지 확인한다.

  - 별로 알려진 기능들은 아니지만 (이라고 문서에는 있는데 내보기엔 다 알려진...) 리액트의 컴포넌트가 마지막으로 렌더링 출력에서 정확하게 동일한 컴포넌트를 반환하는 경우 React는 특정한 하위 컴포넌트들을 다시 렌더링 하지 않는다.

    - props에 들어가있는 children은 리렌더링의 요소에 들어가지 않는다. (children을 자주 써서 알아서 리렌더링 안하게 하는것도 참 좋아보인다!)
    - useMemo로 메모지네이션을 한 요소들도 리렌더링의 요소에 들어가지 않는다.

  - React.memo와의 차이점은 react.memo는 자식 컴포넌트에 의해 제어된다면 위의 두개는 부모 컴포넌트에 의해 제어된다는 차이다.

  - 이렇듯 모든 방식에서 컴포넌트 렌더링을 건너 뛴다라는 것은 해당 하위 트리의 렌더링도 전부 건너뛰는 의미기 때문에 성능에 효과가 있을 수 있다.
