# 리액트의 렌더링 처리 방법

### 초기 렌더링이 완료된 이후 새롭게 리렌더링을 시킬 수 있는 방법은 여러가지 있다.

- 함수형

  - useState 의 setState
  - useReducer 의 dispatch

  useReducer란

  redux처럼 상태관리를 해주는 훅 형태로, action 타입에 따라 어떻게 상태를 변경해줄지 결정해 적용해주는 훅이다.

  - (TODO: 사용은 거의 안할 것 같아 자세한 설명은 따로 작성)

- 클래스형
  - this.setState()
  - this.forceUpdate()
    - 말 그대로 props나 state가 변경되지 않았는데도 강제로 리렌더링을 하기 위한 함수
    - 리액트에서는 사용하지 않는 것을 권장하기에 알고만 있으면 될 듯 하다...
- 그 외에...
  - render(<App />)이 다시 호출되는 경우 -> this.forceUpdate랑 비슷한 원리
  - useSyncExternalStore 훅
    - concurrent feature 기능을 사용할 수 있게 해주는 훅
      - concurrent feature란 (비동기 렌더링이란...)
      - (TODO: 별도로 작성 후 남길 링크)

### 일반적인 렌더링 동작

가장 기본적인 동작은 부모 컴포넌트가 렌더링 되면 리액트는 모든 자식 컴포넌트를 순차적으로 리렌더링 한다라는 것.

즉 컴포넌트를 렌더링 하는 작업은 기본적으로 하위의 모든 컴포넌트 또한 렌더링을 하게 된다.

하지만 중요한 것은 리렌더링이 꼭 나쁜 것은 아니다. 렌더링은 DOM이 바뀌었는지에 대한 확인을 하는 것 뿐이다.

### 리액트의 렌더링 규칙?

렌더링의 기본 규칙은 렌더링이 순수해야하며 부작용이 없어야 한다는 것이다.
많은 사이드 이팩트(부수 효과)가 왜 일어났는지 뚜렷하지도 못하고, 어떤 것을 망가트리는지도 모르기에 이 규칙을 지키기에는 어렵다

예를 들어 console.log는 사이드이펙트를 일으키지만 그 어떠한 것도 망가트리지 않는다. 하지만 props는 사이드이펙트와 함께 어떤 것을 망가트릴지 모른다.

Sebastian Markbage라는 사람이 리액트 렌더링의 규칙을 세웠는데 해당 내용의 요약은 다음과 같다.

렌더링 시 하면 안되는 것들:

- 기존 변수 및 객체를 변경해서는 안됩니다.
- Math.random()이나 Date.now() 같은 난수 혹은 임의의 값을 생성해서는 안됩니다.
- 네트워크 요청을 하면 안됩니다.
- state 업데이트를 할 수 없습니다.

렌더링 시 해도 되는 것들:

- 새로 생성된 변할 수 있는 객체의 변형
- 오류 예외처리
- 캐시된 값 같은 생성되지 않은 데이터의 지연 처리
